import type {ProjectContext, SourceToolInfo, Transport} from '../shared.js';
import {generateToolReturn} from '../shared.js';
import path from 'node:path';
import ts from 'typescript';
import {generateSchemaForTool} from '../typescript-to-zod.js';

function generateTool(tool: SourceToolInfo, checker: ts.TypeChecker): string {
  const params =
    tool.parameters.length > 0
      ? `{${tool.parameters.map((p) => p.name).join(', ')}}`
      : '';
  return `
server.tool(
  {
    name: ${JSON.stringify(tool.name)},
    description: ${tool.description ? JSON.stringify(tool.description) : 'undefined'},
    schema: ${generateSchemaForTool(tool, checker)}
  },
  async (${params}) => {
    const result = await ${tool.name}(${tool.parameters.map((p) => p.name).join(', ')});
    return ${generateToolReturn(tool, checker)};
  },
);
  `.trim();
}

const addImportsForTransport = (
  transport: Transport | undefined,
  imports: string[]
): void => {
  switch (transport) {
    case 'stdio':
      imports.push(`import {StdioTransport} from '@tmcp/transport-stdio';`);
      break;
    case 'http':
      imports.push(
        `import {HttpTransport} from '@tmcp/transport-http';`,
        `import * as http from 'node:http';`
      );
  }
};

const generateTransportInitialization = (
  transport: Transport | undefined
): string => {
  switch (transport) {
    case 'stdio':
      return `
const transport = new StdioTransport(server);
transport.listen();
      `.trim();
    case 'http':
      return `
const transport = new HttpTransport(server, {port: 8080});
const httpServer = http.createServer(async (req, res) => {
  const response = await transport.respond(req);
  res.writeHead(response.status, response.headers);
  res.end(response.body);
});
httpServer.listen(8080);
      `.trim();
    default:
      return `// No transport specified`;
  }
};

export const template = (context: ProjectContext): string => {
  const relativeSourcePath = path.relative(
    path.dirname(context.outputFilePath),
    context.sourceFilePath
  );
  const normalizedSourcePath = (
    relativeSourcePath.startsWith('.')
      ? relativeSourcePath
      : `./${relativeSourcePath}`
  )
    .replace(/\\/g, '/')
    .replace(/\.ts$/, '.js');
  const importNames = context.tools.map((t) => t.name).join(', ');
  const imports: string[] = [
    `import {McpServer} from 'tmcp';`,
    `import {ZodJsonSchemaAdapter} from '@tmcp/adapter-zod';`,
    `import {z} from 'zod';`
  ];
  addImportsForTransport(context.transport, imports);
  if (importNames.length > 0) {
    imports.push(
      `import {${importNames}} from ${JSON.stringify(normalizedSourcePath)};`
    );
  }
  const tools = context.tools
    .map((t) => generateTool(t, context.typeChecker))
    .join('\n\n');

  return `
// Generated by mcp-compiler - do not edit manually
${imports.join('\n')}

const adapter = new ZodJsonSchemaAdapter();
const server = new McpServer(
  {
    name: ${JSON.stringify(context.name)},
    version: ${JSON.stringify(context.version)},
    description: ${context.description ? JSON.stringify(context.description) : 'undefined'},
  },
  {
    adapter,
    capabilities: {
    },
  },
);

${tools}

${generateTransportInitialization(context.transport)}
  `.trim();
};
