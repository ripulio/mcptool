import type {ProjectContext, SourceToolInfo, Transport} from '../shared.js';
import path from 'node:path';
import type ts from 'typescript';
import {generateSchemaForTool} from '../typescript-to-zod.js';

const addImportsForTransport = (
  transport: Transport | undefined,
  imports: string[]
): void => {
  switch (transport) {
    case 'stdio':
      imports.push(
        `import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';`
      );
      break;
    case 'http':
      imports.push(
        `import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';`,
        `import * as http from 'node:http';`
      );
  }
};

function generateTool(tool: SourceToolInfo, checker: ts.TypeChecker): string {
  const params =
    tool.parameters.length > 0
      ? `{${tool.parameters.map((p) => p.name).join(', ')}}`
      : '';
  return `
server.registerTool(
    ${JSON.stringify(tool.name)},
    {
        title: ${JSON.stringify(tool.name)},
        description: ${tool.description ? JSON.stringify(tool.description) : 'undefined'},
        inputSchema: ${generateSchemaForTool(tool, checker)}
    },
    async (${params}) => {
        const output = await ${tool.name}(${tool.parameters.map((p) => p.name).join(', ')});
        return {
            content: [{ type: 'text', text: JSON.stringify(output) }],
            structuredContent: output
        };
    }
);
  `.trim();
}

const generateTransportInitialization = (
  transport: Transport | undefined
): string => {
  switch (transport) {
    case 'stdio':
      return `
const transport = new StdioServerTransport();
await server.connect(transport);
      `.trim();
    case 'http':
      return `
const transport = new HttpTransport(server, {port: 8080});
const httpServer = http.createServer(async (req, res) => {
  const transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
      enableJsonResponse: true
  });
  res.on('close', () => {
      transport.close();
  });
  await server.connect(transport);
  await transport.handleRequest(req, res, req.body);
});
httpServer.listen(8080);
      `.trim();
    default:
      return `// No transport specified`;
  }
};

export const template = (context: ProjectContext): string => {
  const relativeSourcePath = path.relative(
    path.dirname(context.outputFilePath),
    context.sourceFilePath
  );
  const normalizedSourcePath = (
    relativeSourcePath.startsWith('.')
      ? relativeSourcePath
      : `./${relativeSourcePath}`
  ).replace(/\\/g, '/');
  const importNames = context.tools.map((t) => t.name).join(', ');
  const imports: string[] = [
    `import {McpServer} from '@modelcontextprotocol/sdk/server/mcp.js';`,
    `import {z} from 'zod/mini';`
  ];
  addImportsForTransport(context.transport, imports);
  if (importNames.length > 0) {
    imports.push(
      `import {${importNames}} from ${JSON.stringify(normalizedSourcePath)};`
    );
  }
  const tools = context.tools
    .map((t) => generateTool(t, context.typeChecker))
    .join('\n\n');

  return `
// Generated by mcp-compiler - do not edit manually
${imports.join('\n')}

const adapter = new ZodJsonSchemaAdapter();
const server = new McpServer({
  name: ${JSON.stringify(context.name)},
  version: ${JSON.stringify(context.version)},
});

${tools}

${generateTransportInitialization(context.transport)}

  `.trim();
};
